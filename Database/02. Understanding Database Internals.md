
#### **Storage Concepts**
- **Table:** a logical collection of data organized into rows and columns. It represents an entity (e.g., employees) and its attributes.
- **Row_id:** an internal, system-maintained unique identifier for each row in a table. It serves as a physical address pointer (e.g., `(row_id, page_number)`). In some databases like PostgreSQL, it is a separate system column, while in others like MySQL InnoDB, it is synonymous with the primary key.
- **Page:** the fundamental unit of storage and I/O. Rows are stored and read in fixed-size blocks (e.g., 8KB in PostgreSQL, 16KB in MySQL). A single I/O operation reads an entire page, which contains multiple rows, making data access more efficient.
- **IO (Input/Output):** a read or write operation to the disk. The primary performance cost in databases is the number of I/Os, as reading from disk is slow. The goal is to minimize I/Os by reading fewer, larger pages instead of many small pieces of data.
- **Heap data structure:** the unordered, primary storage area where all of a table's data pages are stored. Without an index, finding a specific row requires a full table scan (reading every page in the heap), which is very expensive.
- **Index data structure (b-tree):** a separate, ordered data structure that provides a fast lookup path to data in the heap. It contains a copy of some column values (the key) and a pointer (e.g., `(row_id, page_number)`) to the exact location of the full row in the heap. This allows for efficient searching without scanning the entire table.

**Example of a query:** 
- **Without an index:** A query like `SELECT * FROM emp WHERE emp_id = 10000;` requires a full table scan, reading all 333 pages from the heap to find the one matching row.
- **With an index:** The same query first searches the much smaller b-tree index. The index quickly provides the pointer `(10000, 333)`, telling the database to fetch only Page 333 from the heap, reducing the I/O from 333 to just a few.

<hr class="hr-light" />

#### **Row-Based vs Column-Based Databases**  
- **Row-Oriented Database (Row store):** Data is stored row by row on disk. All column values for a single row are stored together in a single block.  
  - **Optimized for OLTP (Online Transaction Processing):** Workloads consisting of many short, fast, concurrent transactions (e.g., reading a user's profile, updating an order status, inserting a new customer).  
  - **Pros:**  
    - Efficient for queries that need entire rows or multiple columns (e.g., `SELECT * FROM emp WHERE id = 1`).  
    - Optimal for write-heavy operations and frequent updates.  
  - **Cons:**  
    - Inefficient for aggregation queries (e.g., `SUM(salary)`) as entire rows must be scanned.  
    - Compression is less effective due to different data types stored together.  
- **Column-Oriented Database (Column store):** Data is stored column by column on disk. All values for a single column are stored together in contiguous blocks.  
  - **Optimized for OLAP (Online Analytical Processing):** Workloads involving complex queries that scan, aggregate, and analyze large volumes of historical data (e.g., calculating quarterly sales trends, finding averages across billions of records).  
  - **Pros:**  
    - Amazing for aggregation and queries on a few columns (e.g., `SELECT first_name FROM emp WHERE ssn = 666`).  
    - Achieves extremely high compression rates due to data homogeneity within a column.  
    - Requires fewer I/Os for analytical scans as only the necessary columns are read.  
  - **Cons:**  
    - Writes (INSERT/UPDATE/DELETE) are significantly slower.  
    - Inefficient for queries that need to reassemble entire rows from multiple columns.

<hr class="hr-light" />

#### **Database Pages**
- **Purpose:** Databases use fixed-size pages (e.g., 8KB in PostgreSQL, 16KB in MySQL) to store all data (rows, indexes, documents, etc.). This abstracts storage from the database frontend and simplifies reading, writing, and caching.
- **Buffer Pool:** Pages are read/written via a memory pool (buffer pool). Reading one page fetches multiple rows/values, optimizing I/O efficiency. Writes update pages in memory first, with changes journaled to a Write-Ahead Log (WAL) for durability before eventual disk flush.
- **Page Content:**
    - **Row-Stores:** Pack entire rows together for OLTP workloads (e.g., frequent writes/reads of full records).
    - **Column-Stores:** Store values column-wise for OLAP workloads (e.g., aggregations like `SUM(salary)`).
    - **Document/Graph Databases:** Compress documents or persist connectivity patterns for efficient traversal.
- **Page Size Trade-Offs:**
    - Smaller pages: Faster I/O but higher metadata overhead.
    - Larger pages: Lower metadata overhead but slower cold reads/writes.
- **Disk Storage:** Pages are stored in files (e.g., one file per table) as contiguous arrays. To read page `X`, calculate offset `X * Page_Size` in the file.
- **PostgreSQL Page Layout (Critique):**
    - **Header (24 bytes):** Metadata (e.g., free space).
    - **ItemIds (4 bytes each):** Pointers to tuple locations. Enable HOT (Heap Only Tuple) optimization for in-page updates. Criticism: Overhead can be high (e.g., 4KB for 1000 pointers).
    - **Items:** Variable-length tuples (physical row instances).
    - **Special Section:** For B+Tree index leaf pages (prev/next page pointers).
- **Key Insight:** Pages minimize I/O by grouping related data. Design choices (size, layout) balance workload needs (OLTP vs. OLAP) and hardware constraints.