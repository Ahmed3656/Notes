
#### **Storage Concepts**
- **Table:** a logical collection of data organized into rows and columns. It represents an entity (e.g., employees) and its attributes.
- **Row_id:** an internal, system-maintained unique identifier for each row in a table. It serves as a physical address pointer (e.g., `(row_id, page_number)`). In some databases like PostgreSQL, it is a separate system column, while in others like MySQL InnoDB, it is synonymous with the primary key.
- **Page:** the fundamental unit of storage and I/O. Rows are stored and read in fixed-size blocks (e.g., 8KB in PostgreSQL, 16KB in MySQL). A single I/O operation reads an entire page, which contains multiple rows, making data access more efficient.
- **IO (Input/Output):** a read or write operation to the disk. The primary performance cost in databases is the number of I/Os, as reading from disk is slow. The goal is to minimize I/Os by reading fewer, larger pages instead of many small pieces of data.
- **Heap data structure:** the unordered, primary storage area where all of a table's data pages are stored. Without an index, finding a specific row requires a full table scan (reading every page in the heap), which is very expensive.
- **Index data structure (b-tree):** a separate, ordered data structure that provides a fast lookup path to data in the heap. It contains a copy of some column values (the key) and a pointer (e.g., `(row_id, page_number)`) to the exact location of the full row in the heap. This allows for efficient searching without scanning the entire table.

**Example of a query:** 
- **Without an index:** a query like `SELECT * FROM emp WHERE emp_id = 10000;` requires a full table scan, reading all 333 pages from the heap to find the one matching row.
- **With an index:** the same query first searches the much smaller b-tree index. The index quickly provides the pointer `(10000, 333)`, telling the database to fetch only Page 333 from the heap, reducing the I/O from 333 to just a few.

<hr class="hr-light" />

#### **Row-Based vs Column-Based Databases**  
- **Row-Oriented Database (Row store):** data is stored row by row on disk. All column values for a single row are stored together in a single block.  
  - **Optimized for OLTP (Online Transaction Processing):** workloads consisting of many short, fast, concurrent transactions (e.g., reading a user's profile, updating an order status, inserting a new customer).  
  - **Pros:**  
    - Efficient for queries that need entire rows or multiple columns (e.g., `SELECT * FROM emp WHERE id = 1`).  
    - Optimal for write-heavy operations and frequent updates.  
  - **Cons:**  
    - Inefficient for aggregation queries (e.g., `SUM(salary)`) as entire rows must be scanned.  
    - Compression is less effective due to different data types stored together.  
- **Column-Oriented Database (Column store):** data is stored column by column on disk. All values for a single column are stored together in contiguous blocks.  
  - **Optimized for OLAP (Online Analytical Processing):** workloads involving complex queries that scan, aggregate, and analyze large volumes of historical data (e.g., calculating quarterly sales trends, finding averages across billions of records).  
  - **Pros:**  
    - Amazing for aggregation and queries on a few columns (e.g., `SELECT first_name FROM emp WHERE ssn = 666`).  
    - Achieves extremely high compression rates due to data homogeneity within a column.  
    - Requires fewer I/Os for analytical scans as only the necessary columns are read.  
  - **Cons:**  
    - Writes (INSERT/UPDATE/DELETE) are significantly slower.  
    - Inefficient for queries that need to reassemble entire rows from multiple columns.

<hr class="hr-light" />

#### **Database Pages**
- **Purpose:** databases use fixed-size pages (e.g., 8KB in PostgreSQL, 16KB in MySQL) to store all data (rows, indexes, documents, etc.). This abstracts storage from the database frontend and simplifies reading, writing, and caching.
- **Buffer Pool:** pages are read/written via a memory pool (buffer pool). Reading one page fetches multiple rows/values, optimizing I/O efficiency. Writes update pages in memory first, with changes journaled to a Write-Ahead Log (WAL) for durability before eventual disk flush.
- **Page Content:**
    - **Row-Stores:** pack entire rows together for OLTP workloads (e.g., frequent writes/reads of full records).
    - **Column-Stores:** store values column-wise for OLAP workloads (e.g., aggregations like `SUM(salary)`).
    - **Document/Graph Databases:** compress documents or persist connectivity patterns for efficient traversal.
- **Page Size Trade-Offs:**
    - Smaller pages: faster I/O but higher metadata overhead.
    - Larger pages: lower metadata overhead but slower cold reads/writes.
- **Disk Storage:** pages are stored in files (e.g., one file per table) as contiguous arrays. To read page `X`, calculate offset `X * Page_Size` in the file.
- **PostgreSQL Page Layout (Critique):**
    - **Header (24 bytes):** metadata (e.g., free space).
    - **ItemIds (4 bytes each):** pointers to tuple locations. Enable HOT (Heap Only Tuple) optimization for in-page updates. Criticism: overhead can be high (e.g., 4KB for 1000 pointers).
    - **Items:** variable-length tuples (physical row instances).
    - **Special Section:** for B+Tree index leaf pages (prev/next page pointers).
- **Key Insight:** pages minimize I/O by grouping related data. Design choices (size, layout) balance workload needs (OLTP vs. OLAP) and hardware constraints.

<hr class="hr-light" />

#### **Database Management Systems vs. Operating Systems (Parallel Concepts)**
Practically and at a low level databases are just specialized operating systems for data and here's why: 

| Concept                                     | In Operating Systems (OS)                                                                                                         | In Databases (DB)                                                                                                                                    | Why It's the Same Idea                                                          |
| :------------------------------------------ | :-------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------ |
| **Abstraction**                             | Presents the illusion of infinite memory to processes, hiding the complexity of physical RAM and disk.                            | Presents the illusion of infinite, durable, structured data to applications, hiding the complexity of files and disks.                               | Both provide a clean, simple API over messy hardware.                           |
| **Virtual Memory / Pages**                  | Memory is divided into fixed-size **pages**. The OS manages moving pages between RAM and disk.                                    | Data is divided into fixed-size **pages**. The DBMS manages moving pages between the buffer pool and disk.                                           | Both use paging to manage a working set that's larger than available memory.    |
| **Page Table / Page Header**                | The **page table** is a map translating virtual addresses to physical addresses. Each entry has metadata (dirty bit, permission). | The **page header** contains metadata about the page. **ItemIds** are the page's internal "page table," mapping logical row IDs to physical offsets. | Both are metadata structures used to locate the actual data.                    |
| **Buffer Pool / Page Cache**                | The OS has a **page cache** in RAM to hold frequently used disk blocks.                                                           | The DB has a **buffer pool** in RAM to hold frequently used database pages.                                                                          | Both are caches designed to minimize slow disk I/O.                             |
| **System Calls / SQL**                      | Applications request resources via **system calls** (e.g., `read()`, `write()`).                                                  | Applications request data via **SQL queries** (e.g., `SELECT`, `INSERT`).                                                                            | Both are the structured API for requesting services from the system.            |
| **Process Scheduling / Query Optimization** | The OS **scheduler** decides which process runs on the CPU.                                                                       | The DB **query optimizer** decides the best "plan" to access data.                                                                                   | Both are complex decision-makers that choose the most efficient execution path. |
| **Concurrency Control**                     | The OS uses locks, semaphores, and mutexes to prevent processes from interfering.                                                 | The DB uses locks and **MVCC** to prevent transactions from interfering.                                                                             | Both manage simultaneous access to shared resources to ensure correctness.      |
| **Journaling / WAL**                        | Filesystems use **journaling** to ensure consistency after a crash.                                                               | Databases use a **Write-Ahead Log (WAL)** for the same purpose.                                                                                      | Both use a log-for-recovery pattern to guarantee durability and atomicity.      |
