
- **Atomicity:**  ensures that all the queries in a transaction must succeed. If one query fails or if the database went down, all prior successful queries should rollback.

<hr class="hr-light" />

- **Consistency:** ensures that every transaction transforms the database from one valid state to another. So all data must comply with the defined rules, constraints, and relationships (FKs, triggers, check constraints) before and after the transaction. If a transaction violates any of these rules, it will not be allowed to commit, preventing any corruption or invalid data from entering the database. **Consistency is made configurable and often tradable for other benefits in NoSQL Databases**.

<hr class="hr-light" />

- **Isolation:** ensures that concurrently executing transactions do not interfere with each other. Each transaction is processed as if it was the only one running in the system.
	**Issues it prevents:** 
	- **Dirty reads:** when a transaction reads data that has been modified by another transaction but not yet committed. If the other transaction rolls back, the data read becomes invalid as it was never finalized.
	- **Phantom reads:** happens when my current transaction re-executes a query and discovers that new rows have been added or current rows have been deleted by another concurrent transaction, whether it committed or not.
	- **Non-Repeatable reads:** when a transaction reads data that has been modified by another transaction between two reads. (same thing as **Dirty reads** but by a committed transaction)
	- **Lost updates:** when two concurrent transactions update the same data. One transaction's changes are overwritten by the other, leading to loss of one update. Occurs when proper concurrency controls are not implemented.
	
	**Levels of Isolation:**
	- **READ UNCOMMITTED:** transactions can read data that has been modified by other transactions whether they were committed or not.
	- **READ COMMITTED:** ensures that any data read is already committed by other transactions.
	- **REPEATABLE READ:** the transaction ensures that when a query reads a row, that row will remain unchanged while it's running.
	- **SNAPSHOT ISOLATION:** a transaction only sees changes that have been committed up to the start of the transaction.
	- **SERIALIZABLE:** this is the strictest level, ensuring that transactions behave as if they were executed one after the other, rather than concurrently.
	
	✅: may occur &nbsp;&nbsp;&nbsp;&nbsp; ❌: doesn't occur
	
	| Isolation Level      | Dirty Reads | Non-Repeatable Reads | Phantom Reads | Lost Updates |
	|----------------------|------------|-----------------------|---------------|--------------|
	| READ UNCOMMITTED     | ✅         | ✅                    | ✅            | ✅           |
	| READ COMMITTED       | ❌         | ✅                    | ✅            | ✅           |
	| REPEATABLE READ      | ❌         | ❌                    | ✅            | ✅           |
	| SNAPSHOT ISOLATION   | ❌         | ❌                    | ❌            | ✅           |
	| SERIALIZABLE         | ❌         | ❌                    | ❌            | ❌           |
	
	**Database implementation of Isolation:** each DBMS implements Isolation differently.
	- **Pessimistic concurrency:** uses locks on data at the row, table, or page level to prevent lost updates, dirty reads, or non-repeatable reads depending on the isolation level.
	- **Optimistic concurrency:** Minimizes locks by allowing transactions to proceed in parallel and checks for conflicts at commit time, aborting transactions if conflicts are detected.
	- **Repeatable read:** ensures that all rows read during a transaction remain consistent if read again. It often locks the rows read, but could be expensive if you read a lot of rows. PostgreSQL uses snapshot isolation for this level (no phantom reads).
	- **Serializable:** ensures transactions behave as if executed one after another, usually implemented with optimistic concurrency control. Can be implemented pessimistically with `SELECT ... FOR UPDATE`.
	
	**Eventual Consistency:** in a globally scaled system, you don't rely in a single master database to serve every user; instead you have one primary (parent) node and many replicas spread across regions. Whenever someone writes data (like a post) that change goes to the nearest replica first the asynchronously gets recorded to all the others in the background. During that brief window, some replicas might still show the old data until they are all updated within seconds.
	Because not all data are equally critical, systems often treat writes differently: things like bank balances or purchases are synchronously and immediately updated, while "nice-to-have" data like comment counts or view tallies can afford a little lag. **This happens in both SQL and NoSQL databases**. NoSQL databases rely more on this since they don't fully follow consistency principles.


<hr class="hr-light" />

- **Durability:** ensures that once a transaction is committed, its changes are permanent, even in the face of system failures or crashes. This is typically achieved by writing the transaction details to non-volatile storage and employing techniques like transaction logging or journaling.
	**Durability techniques:**
	- **Write Ahead Log (WAL):** a mechanism where every change is first recorded in a log before it's applied to the main database, ensuring durability and aiding recovery after a crash.
	- **Asynchronous snapshot:** captures a consistent copy of the database state without pausing operations, allowing backups or point-in-time recovery with minimal performance impact.
	- **Append Only File (AOF):** a logging method that continuously appends every write operation to a file, enabling the database to be reconstructed by replaying these operations.
	
	**OS cache:** write operations in the operating system typically first enters the OS cache rather than being immediately written to disk. While this caching improves performance it poses a risk of data loss if the cache isn't flushed due to a crash or a machine restart. To ensure durability, the `fsync` OS command can be used to force these writes to be directly written to disk. The issue is that relying on `fsync` can significantly slow down commit operations as of the extra disk I/O overhead, so we need to carefully choose the optimal balance between data safety and system performance.