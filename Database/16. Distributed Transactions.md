#### **Why Distributed Transactions Exist**
In a traditional monolith, you handle a multi-step process—like creating an order, charging a payment, and scheduling shipment—as a single **database transaction**. This ensures **atomicity**: all steps succeed or none do. For example, if payment fails, the entire transaction rolls back, leaving no inconsistent state.

But with **microservices**, each service has its own database. The order service might use PostgreSQL, payments might use Stripe’s API, and shipments might use Cassandra. Even if they shared one database, you can’t run a single ACID transaction across multiple services. This creates a problem:
- If the order is created successfully, but payment fails, you now have an **orphaned order** with no payment. Rolling back isn’t automatic, you need to manually “compensate” (e.g., delete the order). This is error-prone and complex.

That’s where **distributed transactions** come in. They coordinate work across multiple, independent services or databases to ensure logical atomicity.

<hr class="hr-light" />

#### **Common Solutions for Distributed Transactions**

1. **Two-Phase Commit (2PC) & Google Spanner**
	- **How it works**: a coordinator ensures all participants agree to commit or abort. Google Spanner uses **atomic clocks** for ultra-precise time synchronization across globally distributed databases, enabling strict consistency.
	- **Drawback**: complex and requires specialized infrastructure. Not feasible for most teams.
2. **Compensating Transactions (Saga Pattern)**
	- **How it works**: for each action (e.g., `CreateOrder`), you define a compensating action (e.g., `CancelOrder`). If a step fails, you execute the compensations in reverse order.
	- **Drawback**: requires careful design, every service must expose undo logic. Can be brittle if compensations fail.
3. **Event-Driven Architecture with Messaging**
	- **How it works**: services emit events (e.g., “OrderCreated”) to a message broker like Kafka. Downstream services react to these events. If payment fails, a “PaymentFailed” event triggers compensation.
	- **Benefit**: decouples services and makes the flow resilient. Popular and elegant for asynchronous workflows.
4. **Avoid the Problem: Use a Monolith or “Macroservice”**
	- **How it works**: if certain services frequently need transactions, combine them into a larger service (“mini-monolith”) that shares a single database. This avoids distributed transactions entirely.
	- **When to use**: when you can tolerate coupling for the sake of simplicity and consistency.

<hr class="hr-light" />


#### **Key Trade-Offs**
- **Microservices** offer scalability and team autonomy but introduce complexity, debugging, network latency, and distributed transactions.
- **Monoliths** simplify transactions and debugging but can become bottlenecks at very large scale (e.g., Twitter had to break its monolith to handle traffic spikes).

<hr class="hr-light" />

#### **When Do You Need Distributed Transactions?**
- When your business logic requires strict consistency across service boundaries.
- If you’re using microservices for parts of the system that must act atomically (e.g., order processing).

Otherwise, consider simplifying your architecture, sometimes a well-designed monolith is more efficient than over-engineering with microservices.