#### **What NULL Is**
NULL shows the absence of a value. It's not a value itself, but a marker for "unknown" or "missing" data. You need it to represent something that doesn't exist or isn't applicable.

<hr class="hr-light" />

#### **How Databases Store NULLs**
Databases can't use a real value like -1 to mean NULL, because -1 might be valid data. So, they handle it with metadata.

- **The Mechanism:** they add a **NULL bitmap** to each row. Each column gets a bit in this map. If the bit is set, then the value for that column is NULL.
- **The Key Insight:** when a column is NULL, the database doesn't store any data for it.
	- **Variable-length types** (like `VARCHAR`, `TEXT`): if the value is NULL, no space is used at all.
	- **Fixed-length types** (like `INT`, `DATE`): it depends on the engine. PostgreSQL frees the slot, while SQL Server still reserves it but flags it as NULL in the bitmap.
	- Either way the bitmap is what tells the database which columns are actually missing.

The small, fixed overhead of the NULL bitmap is usually a good trade-off for the space you save.

<hr class="hr-light" />

#### **The Problems with NULLs**
NULLs have inconsistent semantics that can trick you:

1. **Inconsistent COUNTs:**
    - `COUNT(*)` returns all rows.
    - `COUNT(column_name)` ignores rows where that column is NULL. This means the same query can return different results based on what you count.
2. **Weird Comparisons:**
    - You can't use `= NULL` or `!= NULL`. These will never return TRUE.
    - You must use the special operators `IS NULL` and `IS NOT NULL`.
3. **Issues with `IN`:**
    - If a subquery inside an `IN` clause returns a NULL, the entire operation can behave unexpectedly, often returning no rows.
4. **Indexing is Database-Specific:**
    - **PostgreSQL** indexes NULLs by default.
    - **Oracle** does not include NULLs in a standard B-tree index. So, a `WHERE column IS NULL` query might force a slow table scan.
    - Some databases let you explicitly choose to include/exclude NULLs in index definitions (e.g., PostgreSQL partial indexes).

<hr class="hr-light" />

#### **The Benefits of NULLs**
Despite the drawbacks, NULLs are essential.

- **Data Accuracy:** they are the only correct way to represent truly unknown information. Using a magic value like '1900-01-01' for a missing birthdate is wrong and error-prone.
- **Handling "Fat Tables":** when you denormalize data into a wide table, many columns will be inapplicable for certain rows. NULL is the correct semantic choice here.
- **Performance via Thin Rows:** this is a critical benefit. Thinner rows mean more rows fit per database page. Since databases read entire pages, this reduces I/O making queries faster. Using NULL for sparse data is more efficient than storing default values that waste space.

<hr class="hr-light" />

#### **Practical Advice**
- **Use `NOT NULL` Constraints:** for columns that must always have a value, define them as `NOT NULL`. This ensures data integrity and can offer minor performance benefits.
- **Use Partial Indexes:** if you mostly query for non-NULL values, create a partial index: `CREATE INDEX ... WHERE column IS NOT NULL;`. This builds a small, fast index by ignoring NULLs.
- **Handle NULLs in Queries:** use functions like `COALESCE` or `IFNULL` to provide default values for NULLs in your result sets.
- **Be Pragmatic:** understand the trade-off. If a query using `IS NULL` is rare (like an admin report), it might be acceptable for it to be slower to benefit the more common user-facing queries.
- **Use NULLs Correctly:** don't avoid NULLs out of fear. Use them when they are the semantically right choice. The performance benefits for sparse data are significant.