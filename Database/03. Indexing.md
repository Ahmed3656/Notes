
#### **The Different Types of Scans**
- **Table Scan:** reads the entire table page-by-page, from beginning to end, inspecting every row to see if it matches the query criteria. Used when a large percentage of the table is needed, the table is very small, or when there are no applicable indexes.
	- Pros: simple and always works. Excellent for sequential I/O efficiency when most data is needed.
	- Cons: highly inefficient if only a few rows are needed from a large table, as it reads everything.
	- Best For: queries that need a large percentage of the table (>20%), very small tables, or when no indexes exist.
- **Index Scan:** uses a B-Tree or similar index to perform binary search to find the exact location of specific rows. After finding the entries, it performs individual random I/O operations to fetch each row from the heap. Used when fetching a very small/specific number of rows or for queries that return a low percentage of the total table rows.
	- Pros: extremely fast (O(log n) lookup) for finding a small number of specific rows (point queries).
	- Cons: performance plummets when fetching many rows due to the overhead of many random I/O operations.
	- Best For: queries that return a very small, specific set of rows (e.g., <1-5% of the table) and highly selective conditions (e.g., `WHERE id = 123`).
- **Index Only Scan:** uses the index **without touching the heap** (table data pages) because all required columns are stored in the index. If the query only requests columns included in the index, Postgres can return results directly from the index.
	- Pros: faster than a regular index scan since it avoids fetching rows from the heap and does less I/O as only the index pages are read.
	- Cons: works only when the index contains all requested columns and requires that the visibility map bits are set, otherwise databases still need to check the heap to ensure rows are visible.
	- Best For: point lookups or queries requesting only indexed columns and situations where you want maximum performance on very frequent reads.
	- Use Case: Enabled by covering indexes (e.g., `CREATE INDEX idx_cover ON table (key_col) INCLUDE (other_col)`). Ideal for queries that select only indexed columns.
- **Bitmap Index Scan:** uses the index to find all matching row locations, builds an **in-memory bitmap** marking relevant heap pages, sorts them by page address, and then fetches all needed rows sequentially. This is the "Sweet Spot" query, it is used when an index scan would be too slow (too many random I/Os) but a table scan would read too much unnecessary data (e.g., `WHERE category_id = 5`, which return ~10% of rows).
	- Pros: combines the filtering of an index with the I/O efficiency of a sequential scan. Perfect for medium-size result sets.
	- Cons: adds memory overhead to build and sort the bitmap. Not ideal for extremely large or extremely small result sets.
	- Best For: medium-selectivity queries (e.g., returning 5-20% of rows) and complex multi-condition filters.
	- Key Advantage: Can perform bitwise operations (AND, OR) on multiple bitmaps from different indexes to efficiently resolve complex `WHERE` clauses (e.g., `category_id = 5 AND status = 'active'`).

<hr class="hr-light" />

#### **Key Indexing vs. Non-Key Indexing**
- **Key Indexing:** a column (or set of columns) explicitly defined as the search key of the index. This key determines the order of the index entries and is used for searching, sorting, and filtering.
	- Usage: Essential for efficiently answering queries with `WHERE`, `ORDER BY`, `GROUP BY`, or `JOIN` clauses that reference the key column(s).
	- Example: `CREATE INDEX ON employees (department_id)` allows fast lookup of all employees in a specific department.
- **Non-Key (Included) Indexing:** additional columns added to an index solely at the leaf level, not as part of the search key. These columns are stored in the index but do not affect the index’s order or structure.
	- Purpose: to cover a query entirely by the index, eliminating the need to access the heap (table) altogether. This is called a **covering index**.
	- Example: `CREATE INDEX ON employees (department_is) INCLUDE (salary)` allows the database to return both `department_id` and `salary` directly from the index without fetching the full row from the heap.
<br/>
- **Creating an Index with Included Columns for Efficiency:**
    - Scenario: a frequent query filters on one column but requires data from another (e.g., `SELECT employee_id, salary FROM employees WHERE department_id = 5`).
    - Inefficient Approach: an index on just `(department_id)` would quickly find the rows but require a **heap lookup** for each row to retrieve `salary`, resulting in random I/O.
    - Efficient Approach: an index on `(department_id) INCLUDE (salary)` stores the `salary` values directly in the leaf pages of the index. The query can be answered **entirely from the index**, avoiding heap accesses and reducing I/O to a single index scan.
    - Benefit: dramatically improves performance for specific queries by making the index **self-sufficient**, trading slightly larger index size for significantly faster read operations.