A software library that manages how data is stored, retrieved, and managed on disk. it handles all the low-level CRUD operations. an engine can be a simple key-value store or a complex system supporting full ACID transactions, foreign keys, and complex queries.

Some database management systems (DBMS) like MySQL and MariaDB allow you to choose from multiple storage engines for different tables. others, like PostgreSQL, come with a single, built-in, highly optimized engine.

<hr class="hr-light" />

#### **B-Tree vs. LSM Tree**
- **B-Tree (Balanced Tree):** the classic database indexing structure. data is stored in a sorted, balanced tree structure where each node can have multiple children.
	- **How it works:** operations like read, insert, and delete are generally O(log n). updates happen in-place, meaning existing data on disk is overwritten.
	- **Pros:** excellent for read-heavy workloads and range queries. predictable performance.
	- **Cons:** can suffer from write amplification. in-place updates can be suboptimal for SSD wear.
- **LSM Tree (Log-Structured Merge Tree):** a modern structure optimized for high-write throughput. it batches writes in memory and later merges them with on-disk files in a cascade of levels.
	- **How it works:** writes are first written to an in-memory structure (Memtable) and a write-ahead log (WAL) for durability. the Memtable is later flushed to disk as a sorted file (SSTable). these files are periodically merged in the background.
	- **Pros:** extremely fast writes . Ideal for SSD drives as it minimizes random writes. High compression rates.
	- **Cons:** read operations can be slower as they may need to check multiple levels. Requires background compaction which can consume I/O.

<hr class="hr-light" />

### **Common Storage Engines**
- **MyISAM (Indexed Sequential Access Method)**
    - **Structure:** B-Tree indexes point directly to rows.
    - **Pros:**
        - Simple and fast for full-table scans and read-heavy workloads.
        - Inserts are fast.
        - Supported by MySQL, MariaDB, and Percona.
    - **Cons:**
        - No transaction support.
        - Table-level locking can bottleneck writes.
        - Updates/deletes cause fragmentation.
        - Not crash-safe; crashes/power failures can corrupt tables (manual repair needed).
        - Owned by Oracle.
- **InnoDB**
    - **Structure:** B+Tree; secondary indexes point to the PK, and the PK points to the row.
    - **Pros:**
        - Default engine for MySQL and MariaDB.
        - Fully ACID compliant.
        - Supports transactions, foreign keys, tablespaces, and row-level locking.
        - Supports spatial operations.
        - Highly reliable and crash-safe.
    - **Cons:**
        - More overhead than MyISAM.
        - Owned by Oracle.
- **XtraDB**
    - **Structure:** fork of InnoDB.
    - **Pros:**
        - Was the default engine for MariaDB until v10.1.
        - Provided performance improvements at the time.
    - **Cons:**
        - Replaced by InnoDB in MariaDB 10.2.
        - No longer maintained; cannot keep up with Oracle’s InnoDB features.
- **Aria**
    - **Structure:** similar to MyISAM, but crash-safe.
    - **Pros:**
        - Created by Michael Widenius for MariaDB.
        - Designed as a successor to MyISAM with crash recovery.
        - All MariaDB system tables (from v10.4) use Aria.
        - Not owned by Oracle.
    - **Cons:**
        - Lacks full transactional features of InnoDB.
- **SQLite**
    - **Structure:** B-Tree (an experimental LSM extension was tried but not beneficial).
    - **Pros:**
        - Serverless and embedded (self-contained library).
        - Zero configuration, ubiquitous (every smartphone/OS/browser has it).
        - Full ACID compliance.
        - Concurrent reads & writes.
        - Syntax resembles PostgreSQL.
    - **Cons:**
        - Table-level locking limits write concurrency.
        - Not suitable for high-write parallel workloads.
- **Berkeley DB (BDB)**
    - **Structure:** key-value embedded database.
    - **Pros:**
        - Supports ACID transactions, locks, replication, and recovery.
        - Used in early versions of Bitcoin Core (later replaced by LevelDB).
        - Was used by MemcacheDB.
    - **Cons:**
        - Currently owned by Oracle.
        - Less commonly used in new projects compared to LevelDB/RocksDB.
- **LevelDB**
    - **Structure:** Log-Structured Merge Tree (LSM).
    - **Pros:**
        - Extremely fast inserts and optimized for SSDs.
        - Avoids in-place updates by merging levels (Memtable → Level 0 → Levels 1–6).
        - Inspired by Google Bigtable.
        - Used in Bitcoin Core, Minecraft, AutoCAD.
    - **Cons:**
        - No transaction support (only get/put/delete).
        - Single-threaded compaction; limited enterprise features.
- **RocksDB**
    - **Structure:** fork of LevelDB with LSM Tree enhancements.
    - **Pros:**
        - Developed by Facebook.
        - Adds transactions, multi-threaded compaction, and advanced enterprise features.
        - High-performance with tunable configuration.
        - Used in MyRocks (MySQL/MariaDB) and MongoRocks (MongoDB).
    - **Cons:**
        - More complex configuration than LevelDB.
- **TokuDB**
    - **Structure:** Fractal Tree indexing (variant of B+Tree with buffered nodes).
    - **Pros:**
        - Excellent for write-heavy workloads with compression.
        - Reduces write amplification compared to B+Trees.
        - Supports transactions, MVCC, and ACID compliance.
        - Created as a MySQL/MariaDB plugin.
    - **Cons:**
        - Development stopped (MariaDB deprecated it in 10.5).
        - Less community adoption compared to InnoDB.
        - Slower for point reads compared to InnoDB.

| Engine         | Indexing Structure | ACID    | Transactions | Locking Granularity | Read Performance | Write Performance  | Notes / Use Cases                  |
| -------------- | ------------------ | ------- | ------------ | ------------------- | ---------------- | ------------------ | ---------------------------------- |
| **MyISAM**     | B+Tree             | ❌       | ❌            | Table-level         | Fast (reads)     | Moderate (inserts) | Legacy MySQL, read-heavy           |
| **InnoDB**     | B+Tree             | ✅       | ✅            | Row-level           | Strong           | Good               | Default in MySQL, general-purpose  |
| **XtraDB**     | B+Tree             | ✅       | ✅            | Row-level           | Strong           | Good               | Fork of InnoDB, deprecated         |
| **Aria**       | B+Tree             | ❌       | ❌            | Table-level         | Strong (reads)   | Good               | MariaDB system tables              |
| **SQLite**     | B+Tree             | ✅       | ✅            | Table-level         | Good             | Limited (parallel) | Embedded, mobile, browsers         |
| **BerkeleyDB** | B+Tree / KV        | ✅       | ✅            | Row-level           | Good             | Good               | Legacy, replaced in Bitcoin        |
| **LevelDB**    | LSM Tree           | ❌       | ❌            | N/A                 | Moderate         | Excellent          | Embedded, fast inserts             |
| **RocksDB**    | LSM Tree           | Partial | ✅            | N/A                 | Good             | Excellent          | Facebook MyRocks, high write scale |
| **TokuDB**     | Fractal Tree       | ✅       | ✅            | Row-level           | Moderate         | Excellent          | Write-heavy compression workloads  |

<hr class="hr-light" />

#### **How to Switch Engines in MySQL/MariaDB**
This is a quick example of creating tables with different storage engines in MySQL.
```sql
-- Check available engines in your database
SHOW ENGINES;

-- Create a table using the MyISAM engine
CREATE TABLE my_logs (
    id INT AUTO_INCREMENT PRIMARY KEY,
    message TEXT
) ENGINE=MyISAM;

-- Create a table using the InnoDB engine
CREATE TABLE my_orders (
    id INT AUTO_INCREMENT PRIMARY KEY,
    amount DECIMAL(10,2)
) ENGINE=InnoDB;

-- Alter an existing table to use a different engine
ALTER TABLE my_logs ENGINE = Aria;
```

<hr class="hr-light" />

#### **When to Choose Which Engine**
The choice of engine is a fundamental trade-off between read performance, write performance, and data integrity.

**Primary use cases:**

- **Need ACID compliance**  —> Choose **InnoDB** or **SQLite**. essential for financial data, user orders, or any system where data integrity is critical.
- **Read-heavy, simple analytics**  —> **MyISAM** or **Aria** can be faster for large, static datasets where transactions are not needed.
- **Blazing fast writes**  —> **RocksDB** or **LevelDB** (or databases built on them like Cassandra) are ideal for logging, metrics, and real-time analytics.
- **Embedded application or local cache**  —> **SQLite** is the undisputed king. it's in your phone, browser, and probably your OS.
- **Using MariaDB**  —> for system tables, you're using **Aria**. for your own tables, **InnoDB** is the default and safe choice for most workloads.

---

#### **Real-World Examples**
- **Wikipedia:** one of the largest MySQL users. historically used a mix of InnoDB and MyISAM tables, optimizing each for its purpose.
- **Facebook:** developed **RocksDB** to handle their massive scale of writes. they later integrated it back into MySQL as **MyRocks** to improve efficiency and reduce storage costs.
- **Android & iOS:** use **SQLite** extensively to store application data locally on devices.
- **Bitcoin Core:** originally used **Berkeley DB**, but switched to **LevelDB** for its performance characteristics needed for the blockchain.
- **MySQL itself:** the ability to support multiple engines is a core feature that has kept it relevant for decades, allowing it to adapt to new storage trends.

<hr class="hr-light" />

#### **Notes**

- **B-Tree based database storage engines:** Oracle, SQL Server, IBM DB2, PostgreSQL, MySQL, mongoDB, Couchbase
- **LSM Tree based database storage engines:** Apache Cassandra, Apache HBASE, Google Cloud Bigtable, Elasticsearch, InfluxDB, LevelDB, RocksDB, YugaByte DB