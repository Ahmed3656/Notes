Database security is the practice of protecting database content, structure, and access from unauthorized use, corruption, or theft. It's a critical layer in the defense of any application, ensuring data confidentiality, integrity, and availability. A breach can lead to data loss, compliance violations, and severe reputational damage.

#### **Core Concepts & Attack Vectors**
The primary goal is to protect data at rest and in transit from common threats. A key insight is that security is often weakest at the points where data is processed or moved.

- **Data in Transit:** this is the communication between a client (e.g., your application server) and the database server. Without encryption, this traffic is sent in plaintext over the network, making it vulnerable to interception and sniffing.
- **Data at Rest:** this is the data physically stored on the database server's disks. If stolen, unencrypted data is immediately readable.
- **Injection Attacks:** the most common threat is SQL Injection, where an attacker executes malicious SQL commands by manipulating application input. This can lead to data exposure, modification, or deletion.
- **Excessive Privileges:** a fundamental mistake is connecting applications to the database using a superuser or owner account. If an application is compromised, the attacker inherits these extensive privileges, allowing them to drop tables, modify schemas, or access all data.

---

#### **Securing Data in Transit with TLS/SSL**
Encrypting the connection between the client and the database is non-negotiable, especially in cloud or Kubernetes environments where network paths cannot be assumed to be private.

**How it works:** [TLS](../Backend/2.06%20Transport%20Layer%20Security%20(TLS).md) (Transport Layer Security) creates an encrypted tunnel. The database server presents a certificate to the client to prove its identity. All data passing through this tunnel is encrypted, preventing eavesdropping.

**How to Implement (Postgres Example):**

1. **Generate a Self-Signed Certificate (for testing):**
	```bash
	openssl req -new -x509 -days 365 -nodes -text -out server.crt \
	-keyout server.key -subj "/CN=localhost"
	```
2. **Secure the Private Key:** the private key must be readable only by the database process.
	```bash
	chmod 600 server.key
	chown postgres:postgres server.key
	```
3. **Configure Postgres (`postgresql.conf`):** enable SSL and point to the certificate and key files.
	```conf
	ssl = on
	ssl_cert_file = 'server.crt'
	ssl_key_file = 'server.key'
	```
4. **Restart the Database:** apply the configuration changes.
5. **Client Enforcement:** in your connection string or client configuration, you can set `sslmode=require` to force an encrypted connection and reject unencrypted ones.

<hr class="hr-light" />

#### **Wire Protocol Analysis & The Need for Encryption**
Analyzing database wire protocols with a tool like Wireshark highlights the critical importance of encryption.

- **Unencrypted Traffic (e.g., Postgres):** without TLS, every part of the conversation is visible:
    - The exact SQL query strings (`SELECT * FROM employees`).
    - Authentication handshakes, including the hashed password sent from the client to the server.
    - Database names, usernames, and server version details.  
    This is a goldmine for an attacker, allowing them to see sensitive data and understand your database schema.
- **Encrypted Traffic (e.g., MongoDB Atlas):** Modern databases like MongoDB encrypt connections by default. While you can see the TCP handshake and TLS negotiation, the actual database protocol messages (queries, results, authentication) are completely opaque without the session keys. This is the ideal state and ensures privacy even on public networks.

<hr class="hr-light" />

#### **Input Validation & SQL Injection Prevention**
SQL Injection remains a top vulnerability. It occurs when user input is directly concatenated into SQL queries without sanitization.

- **The Vulnerability:** an input like `'; DROP TABLE users; --` could terminate the intended query and execute a malicious one if spliced directly into a query string.
- **The Solution: use Parameterized Queries (Prepared Statements).** This ensures user input is always treated as data, never as executable SQL code.  
    **Vulnerable:**
    ```javascript
    const query = `SELECT * FROM users WHERE email = '${email}'`;
    ```
    **Secure:**
    ```javascript
    const query = `SELECT * FROM users WHERE email = $1`;
    const res = await pool.query(query, [email]);
    ```

<hr class="hr-light" />

#### **Principle of Least Privilege & User Management**
This is arguably the most important practice. Application database users should only have the absolute minimum permissions required to function.

**Separation of DDL and DML Users:**
- **DDL (Data Definition Language):** operations that define the schema: `CREATE`, `ALTER`, `DROP` tables, indexes, etc. These should be executed by a high-privilege **schema owner** user (e.g., `schema_owner`). This user is _only_ used during migrations or schema updates, never by the running application.
- **DML (Data Manipulation Language):** operations that manipulate data: `SELECT`, `INSERT`, `UPDATE`, `DELETE`. These are performed by the application at runtime using low-privilege users (e.g., `app_read`, `app_write`).

**How to Implement:**
1. **Create Specific Roles:** don't use the default superuser. Create separate users for different operations.
	- `schema_owner`: has `CREATE`, `ALTER`, `DROP` privileges on the database/schema. _Not used by the application._
    - `app_read`: only has `SELECT` permission on specific tables.
    - `app_write`: only has `INSERT`, `UPDATE` on specific tables.
    - `app_delete`: only has `DELETE` on specific tables.
2. **Manage Permissions Granularly:** use `GRANT` statements to assign precise permissions. Remember to grant permissions on related sequences if tables use `SERIAL` primary keys.
    ```sql
    -- Schema owner creates the table
	-- Then, grants privileges to application users
    GRANT SELECT ON TABLE table_name TO app_read;
    GRANT INSERT ON TABLE table_name TO app_write;
    GRANT USAGE, SELECT ON SEQUENCE seq_name TO app_write;
    GRANT DELETE ON TABLE table_name TO app_delete;
	```
3. **Use Connection Pooling with Different Users:** configure your application to use different connection pools (with different user credentials) for different routes or operations. A read-only API endpoint should use the `app_read` pool.

**What it Prevents:** an attacker who successfully performs SQL Injection on a `SELECT` query will be severely limited if the application connects with a read-only user. They cannot drop tables, insert data, or delete records because the `app_read` user lacks DDL and other DML privileges.

<hr class="hr-light" />

#### **Operational Limits & DoS Considerations**
Security also involves protecting the database from being overwhelmed.

**Query Size Limits:** While databases like Postgres can handle very large queries (e.g., multi-megabyte statements), this is a bad practice. Extremely large queries can consume excessive network bandwidth, memory, and CPU, potentially crashing the database server or making it unresponsive, a form of Denial-of-Service (DoS) attack. Always implement pagination (`LIMIT/OFFSET`) and avoid unbounded result sets.

<hr class="hr-light" />

#### **Homomorphic Encryption (Future Paradigm)**
Homomorphic encryption is a revolutionary cryptographic technique that allows computations to be performed directly on encrypted data without needing to decrypt it first.

- **How it works:** it uses complex algorithms that transform data into ciphertext. Special mathematical operations on this ciphertext yield a result that, when decrypted, matches the result of the same operations performed on the original plaintext. For example: `Encrypt(5) + Encrypt(3) —> Encrypt(8)`.
- **The Key Benefit:** it enables true end-to-end encryption in scenarios previously impossible. A cloud database provider could store your data, perform queries on it, and return results without ever having the decryption key or seeing the raw data. This solves the fundamental trust issue with third-party data processors.
- **The Current Drawback:** the technology is currently **impractically slow** for most real-time applications. A simple search on a tiny encrypted dataset can take minutes instead of milliseconds due to the immense computational overhead. It is currently best suited for asynchronous, offline processing of highly sensitive data where latency is not a concern.
- **Future Potential:** despite its current inefficiency, it represents the future of privacy-preserving computing. It could eventually allow for secure encrypted database engines, privacy-preserving analytics, and layer-7 load balancers that can route traffic based on encrypted content without TLS termination.

---

#### **Pros**
- **Defense in Depth:** implementing multiple layers (TLS, least privilege, input validation) creates a robust security posture where a failure in one layer doesn't lead to a total breach.
- **Data Confidentiality:** encryption ensures data is useless to anyone who intercepts it without the keys.
- **Data Integrity:** prevents unauthorized modification or destruction of data.
- **Compliance:** many regulations (GDPR, HIPAA, PCI DSS) require these security measures to be in place.

<hr class="hr-light" />

#### **Cons**
- **Performance Overhead:** TLS encryption/decryption adds minimal but non-zero CPU overhead. Complex user/permission management can add development and operational complexity.
- **Key Management:** securely generating, storing, and rotating TLS and encryption keys is a complex challenge in itself.
- **Implementation Complexity:** requires careful planning and ongoing maintenance compared to an insecure, default setup.